# Conca TTS

Trivial concatenative on-premise text to speech.

Conca TTS is a simple on-premise concatenative TTS library, exposed as a nodejs package.
The speech is produced by concatenating audio files sources for letters, words, entire phrases. 

## Step 1: off-line data preparation: speech files data base

Following a configuration file(s), all audio files required must be produced, with a recording or a download.
Audio source files could be made in two different ways:

1. Human-made: prerecorded audio files, result of a voice actor recordings

2. Synthetic voices files, generated by any cloud-based TTS and downloaded as files. 
   - E.g. free of charge, using Google Translate Speech library: https://github.com/zlargon/google-tts 
   - using any cloud-based TTS as Amazon Polly, Google Cloud Platform Text-to-Speech, etc.

Input texts could be configured as characters, words, phrases:

- 2.1 **Static phrases**
 
  It's the simplest scenario: you have a list of static, ready done, phrases. By example:
  ```
  Looks like her company has three containers set to sail for tonight.
  ```
  The above sentence corresponds to the audio (speech) file with some naming convention e.g.
  `your/path/speech/en/looks_like_her_company_has_three_containers_set_to_sail_for_tonight.ogg` 
  or with a obscure name/UUID as:
  `your/path/speech/en/1.ogg`.
 
  From the API perspective you have a possible method:

  ```javascript
  const fileName = conca.ttsfile('Looks like her company has three containers set to sail for tonight', 'en')
  // -> 'your/path/speech/en/looks_like_her_company_has_three_containers_set_to_sail_for_tonight.ogg'
  ```

- 2.2 **Character-by-character spelling**

  We need a ready done letters/symbols audio files, for spoken spelling of 
  single chars, acronyms, numbers, or alphanumeric codes, unknown words (not included in custom grammar):
 
  Examples (alphanumeric codes):
  ```
  RAIU 690011 4 25 U1
  CSQU3054383
  1006.760
  ```
  BTW, the two initial lines are container codes with format ISO6346 (see: https://github.com/solyarisoftware/iso6346).
  In the case of an alphanumeric sequence of chars, the required spoken spelling is the concatenation of letter-by-letter speech:

  Original input text: 
  ```
  CSQU3054383
  ```
  Text to speech spelled as sequence of single characters: 
  ```
  C S Q U 3 0 5 4 3 8 3
  ```
  Corresponding to pseudo-phonetic spelling audio:
  ```
  sii kiu iu three ou five four three eight three
  ```

- 2.3 **Template literals**

  Template literals are string literals allowing embedded expressions. 
  They are static phrases containing also entities to be resolved at run-time. By example:
  ```
  Container JL1349-76 has been cleared for pick-up.
  ```
  in the example the entity `JL1349-76` is a container code, to be spelled as a `{alphanumeric_code}`. 
  At the configuration level, a template literal could have a syntax like: 
  ```
  Container {alphanumeric_code} has been cleared for pick-up.
  ```
  That could be a concatenation of 3 strings component parts:
  - `'Container'` static string
  - ` {alphanumeric_code} `, char-by-char spelling
  - `'has been cleared for pick-up.'`, static string

  At run-time, the TTS translation function must recognize the template literal, concatenating the sequences.

- 2.4 **Word concatenation** 

  Phrases built concatenating words and or letters (that's the common sense, general case of concatenative text-to-speech).
  Apparently it's a "worst case" because the system has to preset all the words of the grammar.
  In the example: 
  ```
  Container JL1349-76 has been cleared for pick-up.
  ```
  The sentence could split in blank separated word tokens:
  ```
  Container
  JL1349-76
  has
  been
  cleared
  for
  pick-up.
  ```

  The downside of this approach is that having a file for each word, 
  imply a run time concatenation, with possible unnatural sounding sequence,
  due to the static file sequencing.


## Step 2: run-time environment

The target environment is any sort of embedded system, 
with scarse CPU resources, but the need of a "real-time" responsive speech output.

### API functions signature

Output as: 
  - an audio file, lossless (e.g. `wav`) or in a compressed lossy compression format (e.g. [`ogg`](https://en.wikipedia.org/wiki/Opus_(audio_format)))
 
    ```javascript
    /**
     * ttsfile 
     *
     * @param {String} text
     * @param {string} language_code ('en-us', 'it', )
     * @param {String} audio coding format (wav/ogg/etc.)
     * @return {String} filename
     */
    ```

    Example:
    ```javascript
    const fileName = conca.ttsbuf('Container JL1349-76 has been cleared for pick-up.', 'en', 'ogg')
    ```

  - a memory buffer in the above specified format.
 
    ```javascript
    /**
     * ttsbuf 
     *
     * @param {String} text
     * @param {string} language_code ('en-us', 'it', )
     * @param {String} audio coding format (wav/ogg/etc.)
     * @return {buffer}  
     */
    ```

    Example:
    ```javascript
    const buffer = conca.ttsbuf('Il container JL1349-76 Ã¨ pronto per il ritiro.', 'it', 'ogg')
    ```

### Concatenation backend

The trivial approach is to use `ffmpeg` or `sox`, 
with a background process that create dynamic concatenations.
See:
- ffmpeg audio files concatenation:
  - https://trac.ffmpeg.org/wiki/Concatenate
  - https://superuser.com/questions/587511/concatenate-multiple-wav-files-using-single-command-without-extra-file/1307384#1307384

- sox audio files concatenation:
  - https://superuser.com/questions/571463/how-do-i-append-a-bunch-of-wav-files-while-retaining-not-zero-padded-numeric
  - https://superuser.com/questions/64164/linux-command-to-concatenate-audio-files-and-output-them-to-ogg
  - http://sox.sourceforge.net/Docs/Documentation
  - https://stackoverflow.com/questions/10721089/combine-two-audio-files-with-a-command-line-tool
  - https://askubuntu.com/questions/20507/concatenating-several-mp3-files-into-one-mp3
  - http://sox.sourceforge.net/sox.html#EFFECTS


### Caching

To speedup performances, a caching could improve elapsed times. 

---
